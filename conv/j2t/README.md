<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# j2t

```go
import "github.com/cloudwego/dynamicgo/conv/j2t"
```

## Index

- [type BinaryConv](<#type-binaryconv>)
  - [func NewBinaryConv(opts conv.Options) BinaryConv](<#func-newbinaryconv>)
  - [func (self *BinaryConv) Do(ctx context.Context, desc *thrift.TypeDescriptor, jbytes []byte) (tbytes []byte, err error)](<#func-binaryconv-do>)
  - [func (self *BinaryConv) DoInto(ctx context.Context, desc *thrift.TypeDescriptor, jbytes []byte, buf *[]byte) (err error)](<#func-binaryconv-dointo>)
  - [func (self *BinaryConv) SetOptions(opts conv.Options)](<#func-binaryconv-setoptions>)
- [type HTTPConv](<#type-httpconv>)
  - [func NewHTTPConv(proto meta.Encoding, fnDesc *thrift.FunctionDescriptor) *HTTPConv](<#func-newhttpconv>)
  - [func (h HTTPConv) Do(ctx context.Context, req http.RequestGetter, opt conv.Options) (tbytes []byte, err error)](<#func-httpconv-do>)
  - [func (h HTTPConv) DoInto(ctx context.Context, req http.RequestGetter, buf *[]byte, opt conv.Options) (err error)](<#func-httpconv-dointo>)


## type BinaryConv

BinaryConv is a converter from json to thrift binary

```go
type BinaryConv struct {
    // contains filtered or unexported fields
}
```

### func NewBinaryConv

```go
func NewBinaryConv(opts conv.Options) BinaryConv
```

NewBinaryConv returns a new BinaryConv

### func \(\*BinaryConv\) Do

```go
func (self *BinaryConv) Do(ctx context.Context, desc *thrift.TypeDescriptor, jbytes []byte) (tbytes []byte, err error)
```

#### Do converts json bytes \(jbytes\) to thrift binary \(tbytes\)

desc is the thrift type descriptor of the thrift binary, usually it the request STRUCT type ctx is the context, which can be used to pass arguments as below: \- conv.CtxKeyHTTPRequest: http.RequestGetter as http request \- conv.CtxKeyThriftRespBase: thrift.Base as base metadata of thrift response

<details><summary>Example</summary>
<p>

```go
{

	desc := getExampleDesc()
	data := getExampleData()

	cv := NewBinaryConv(opts)

	out, err := cv.Do(context.Background(), desc, data)
	if err != nil {
		panic(err)
	}

	exp := example3.NewExampleReq()
	err = json.Unmarshal(data, exp)
	if err != nil {
		panic(err)
	}
	act := example3.NewExampleReq()
	_, err = act.FastRead(out)
	if err != nil {
		panic(err)
	}
	if !reflect.DeepEqual(exp, act) {
		panic("not equal")
	}
}
```

</p>
</details>

### func \(\*BinaryConv\) DoInto

```go
func (self *BinaryConv) DoInto(ctx context.Context, desc *thrift.TypeDescriptor, jbytes []byte, buf *[]byte) (err error)
```

DoInto behaves like Do, but it writes the result to buffer directly instead of returning a new buffer

### func \(\*BinaryConv\) SetOptions

```go
func (self *BinaryConv) SetOptions(opts conv.Options)
```

SetOptions sets options

## type HTTPConv

HTTPConv is a converter from http request to thrift message

```go
type HTTPConv struct {
    // contains filtered or unexported fields
}
```

### func NewHTTPConv

```go
func NewHTTPConv(proto meta.Encoding, fnDesc *thrift.FunctionDescriptor) *HTTPConv
```

NewHTTPConv returns a new HTTPConv, which contains the thrift message header and footer

proto is specified thrift encoding protocol \(meta.EncodingThriftBinary|meta.EncodingThriftCompact\) fnDesc is the thrift method descriptor corresponding to the http request url

### func \(HTTPConv\) Do

```go
func (h HTTPConv) Do(ctx context.Context, req http.RequestGetter, opt conv.Options) (tbytes []byte, err error)
```

Do converts http request into thrift message. req body must be one of following: \- json \(application/json\) \- url encoded form \(application/x\-www\-form\-urlencoded\) \- empty

### func \(HTTPConv\) DoInto

```go
func (h HTTPConv) DoInto(ctx context.Context, req http.RequestGetter, buf *[]byte, opt conv.Options) (err error)
```

<details><summary>Example</summary>
<p>

```go
{

	svc, err := thrift.NewDescritorFromPath(exampleIDLPath)
	if err != nil {
		panic(err)
	}
	fn := svc.Functions()["ExampleMethod"]

	cv := NewHTTPConv(meta.EncodingThriftBinary, fn)

	jdata := `{"msg":"hello","InnerBase":{}}`
	stdreq, err := stdhttp.NewRequest("POST",
		"http://localhost:8080/example?query=1,2,3&inner_query=中文",
		strings.NewReader(jdata))
	if err != nil {
		panic(err)
	}
	stdreq.Header.Set("Content-Type", "application/json")
	stdreq.Header.Set("heeader", "true")
	stdreq.Header.Set("inner_string", "igorned")

	req, err := http.NewHTTPRequestFromStdReq(
		stdreq,
		http.Param{Key: "path", Value: "OK"},
		http.Param{Key: "inner_string", Value: "priority"},
	)

	buf := make([]byte, 0, len(jdata)*2/3)

	err = cv.DoInto(context.Background(), req, &buf, opts)
	if err != nil {
		panic(err)
	}

	p := thrift.NewBinaryProtocol(buf)
	method, mType, seqID, reqID, stru, err := p.UnwrapBody()
	println(method, mType, seqID, reqID)

	act := example3.NewExampleReq()
	_, err = act.FastRead(stru)
	if err != nil {
		panic(err)
	}
	spew.Dump(act)
}
```

</p>
</details>



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
