<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# t2j

```go
import "github.com/cloudwego/dynamicgo/conv/t2j"
```

## Index

- [type BinaryConv](<#type-binaryconv>)
  - [func NewBinaryConv(opts conv.Options) BinaryConv](<#func-newbinaryconv>)
  - [func (self *BinaryConv) Do(ctx context.Context, desc *thrift.TypeDescriptor, tbytes []byte) (json []byte, err error)](<#func-binaryconv-do>)
  - [func (self *BinaryConv) DoInto(ctx context.Context, desc *thrift.TypeDescriptor, tbytes []byte, buf *[]byte) (err error)](<#func-binaryconv-dointo>)
  - [func (self *BinaryConv) SetOptions(opts conv.Options)](<#func-binaryconv-setoptions>)
- [type HTTPConv](<#type-httpconv>)
  - [func NewHTTPConv(proto meta.Encoding, desc *thrift.FunctionDescriptor) *HTTPConv](<#func-newhttpconv>)
  - [func (h HTTPConv) Do(ctx context.Context, resp http.ResponseSetter, tbytes []byte, opt conv.Options) (err error)](<#func-httpconv-do>)
  - [func (h HTTPConv) DoInto(ctx context.Context, resp http.ResponseSetter, tbytes []byte, buf *[]byte, opt conv.Options) (err error)](<#func-httpconv-dointo>)


## type BinaryConv

BinaryConv is a converter from thrift binary to json

```go
type BinaryConv struct {
    // contains filtered or unexported fields
}
```

### func NewBinaryConv

```go
func NewBinaryConv(opts conv.Options) BinaryConv
```

NewBinaryConv returns a new BinaryConv

### func \(\*BinaryConv\) Do

```go
func (self *BinaryConv) Do(ctx context.Context, desc *thrift.TypeDescriptor, tbytes []byte) (json []byte, err error)
```

#### Do converts thrift binary \(tbytes\) to json bytes \(jbytes\)

desc is the thrift type descriptor of the thrift binary, usually it is a response STRUCT type ctx is the context, which can be used to pass arguments as below: \- conv.CtxKeyHTTPResponse: http.ResponseSetter as http request \- conv.CtxKeyThriftRespBase: thrift.Base as base metadata of thrift response

<details><summary>Example</summary>
<p>

```go
{

	desc := thrift.FnResponse(thrift.GetFnDescFromFile("testdata/idl/example3.thrift", "ExampleMethod", thrift.Options{}))
	data := getExample3Data()

	cv := NewBinaryConv(opts)

	out, err := cv.Do(context.Background(), desc, data)
	if err != nil {
		panic(err)
	}

	// validate result
	var exp, act example3.ExampleResp
	_, err = exp.FastRead(data)
	if err != nil {
		panic(err)
	}
	err = json.Unmarshal(out, &act)
	if err != nil {
		panic(err)
	}
	if !reflect.DeepEqual(exp, act) {
		panic("not equal")
	}
}
```

</p>
</details>

### func \(\*BinaryConv\) DoInto

```go
func (self *BinaryConv) DoInto(ctx context.Context, desc *thrift.TypeDescriptor, tbytes []byte, buf *[]byte) (err error)
```

DoInto behaves like Do, but it writes the result to buffer directly instead of returning a new buffer

### func \(\*BinaryConv\) SetOptions

```go
func (self *BinaryConv) SetOptions(opts conv.Options)
```

SetOptions sets options

## type HTTPConv

HTTPConv is a converter from thrift message to http response

```go
type HTTPConv struct {
    // contains filtered or unexported fields
}
```

### func NewHTTPConv

```go
func NewHTTPConv(proto meta.Encoding, desc *thrift.FunctionDescriptor) *HTTPConv
```

NewHTTPConv returns a new HTTPConv

### func \(HTTPConv\) Do

```go
func (h HTTPConv) Do(ctx context.Context, resp http.ResponseSetter, tbytes []byte, opt conv.Options) (err error)
```

Do converts thrift message \(tbytes\) into http response. resp body is set as json protocol if has

### func \(HTTPConv\) DoInto

```go
func (h HTTPConv) DoInto(ctx context.Context, resp http.ResponseSetter, tbytes []byte, buf *[]byte, opt conv.Options) (err error)
```

DoInto converts the thrift message \(tbytes\) to into buf in JSON protocol, as well as other http response arguments. WARN: This will set buf to resp, thus DONOT reuse the buf afterward.

<details><summary>Example</summary>
<p>

```go
{

	desc := thrift.GetFnDescFromFile("testdata/idl/example3.thrift", "ExampleMethod", thrift.Options{})

	data := getExample3Data()
	in, err := thrift.WrapBinaryBody(data, "ExampleMethod", thrift.REPLY, thrift.FieldID(0), 1)
	if err != nil {
		panic(err)
	}

	resp := http.NewHTTPResponse()
	resp.StatusCode = 200

	cv := NewHTTPConv(meta.EncodingThriftBinary, desc)

	buf := make([]byte, 0, len(data)*2)
	err = cv.DoInto(context.Background(), resp, in, &buf, opts)
	if err != nil {
		panic(err)
	}

	// validate result
	var act example3.ExampleResp
	err = json.Unmarshal(buf, &act)
	if err != nil {
		panic(err)
	}

	spew.Dump(act)

	spew.Dump(resp)
}
```

</p>
</details>



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
