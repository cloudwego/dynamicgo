// Code generated by thriftgo (0.3.15) (fastgo). DO NOT EDIT.
package baseline

import (
	"encoding/binary"
	"fmt"
	"unsafe"

	"github.com/cloudwego/gopkg/protocol/thrift"
)

func (p *Simple) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.ByteField ID:1 thrift.I08
	off += 3
	off += 1

	// p.I64Field ID:2 thrift.I64
	off += 3
	off += 8

	// p.DoubleField ID:3 thrift.DOUBLE
	off += 3
	off += 8

	// p.I32Field ID:4 thrift.I32
	off += 3
	off += 4

	// p.StringField ID:5 thrift.STRING
	off += 3
	off += 4 + len(p.StringField)

	// p.BinaryField ID:6 thrift.STRING
	off += 3
	off += 4 + len(p.BinaryField)
	return off + 1
}

func (p *Simple) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Simple) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.ByteField ID:1 thrift.I08
	b[off] = 3
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	b[off] = byte(p.ByteField)
	off++

	// p.I64Field ID:2 thrift.I64
	b[off] = 10
	binary.BigEndian.PutUint16(b[off+1:], 2)
	off += 3
	binary.BigEndian.PutUint64(b[off:], uint64(p.I64Field))
	off += 8

	// p.DoubleField ID:3 thrift.DOUBLE
	b[off] = 4
	binary.BigEndian.PutUint16(b[off+1:], 3)
	off += 3
	binary.BigEndian.PutUint64(b[off:], *(*uint64)(unsafe.Pointer(&p.DoubleField)))
	off += 8

	// p.I32Field ID:4 thrift.I32
	b[off] = 8
	binary.BigEndian.PutUint16(b[off+1:], 4)
	off += 3
	binary.BigEndian.PutUint32(b[off:], uint32(p.I32Field))
	off += 4

	// p.StringField ID:5 thrift.STRING
	b[off] = 11
	binary.BigEndian.PutUint16(b[off+1:], 5)
	off += 3
	off += thrift.Binary.WriteStringNocopy(b[off:], w, p.StringField)

	// p.BinaryField ID:6 thrift.STRING
	b[off] = 11
	binary.BigEndian.PutUint16(b[off+1:], 6)
	off += 3
	off += thrift.Binary.WriteBinaryNocopy(b[off:], w, p.BinaryField)

	b[off] = 0
	return off + 1
}

func (p *Simple) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x103: // p.ByteField ID:1 thrift.I08
			p.ByteField, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20a: // p.I64Field ID:2 thrift.I64
			p.I64Field, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x304: // p.DoubleField ID:3 thrift.DOUBLE
			p.DoubleField, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x408: // p.I32Field ID:4 thrift.I32
			p.I32Field, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50b: // p.StringField ID:5 thrift.STRING
			p.StringField, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x60b: // p.BinaryField ID:6 thrift.STRING
			p.BinaryField, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Simple[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *PartialSimple) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.ByteField ID:1 thrift.I08
	off += 3
	off += 1

	// p.DoubleField ID:3 thrift.DOUBLE
	off += 3
	off += 8

	// p.BinaryField ID:6 thrift.STRING
	off += 3
	off += 4 + len(p.BinaryField)
	return off + 1
}

func (p *PartialSimple) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *PartialSimple) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.ByteField ID:1 thrift.I08
	b[off] = 3
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	b[off] = byte(p.ByteField)
	off++

	// p.DoubleField ID:3 thrift.DOUBLE
	b[off] = 4
	binary.BigEndian.PutUint16(b[off+1:], 3)
	off += 3
	binary.BigEndian.PutUint64(b[off:], *(*uint64)(unsafe.Pointer(&p.DoubleField)))
	off += 8

	// p.BinaryField ID:6 thrift.STRING
	b[off] = 11
	binary.BigEndian.PutUint16(b[off+1:], 6)
	off += 3
	off += thrift.Binary.WriteBinaryNocopy(b[off:], w, p.BinaryField)

	b[off] = 0
	return off + 1
}

func (p *PartialSimple) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x103: // p.ByteField ID:1 thrift.I08
			p.ByteField, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x304: // p.DoubleField ID:3 thrift.DOUBLE
			p.DoubleField, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x60b: // p.BinaryField ID:6 thrift.STRING
			p.BinaryField, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_PartialSimple[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Nesting) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.String_ ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.String_)

	// p.ListSimple ID:2 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.ListSimple {
		off += v.BLength()
	}

	// p.Double ID:3 thrift.DOUBLE
	off += 3
	off += 8

	// p.I32 ID:4 thrift.I32
	off += 3
	off += 4

	// p.ListI32 ID:5 thrift.LIST
	off += 3
	off += 5
	off += len(p.ListI32) * 4

	// p.I64 ID:6 thrift.I64
	off += 3
	off += 8

	// p.MapStringString ID:7 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapStringString {
		off += 4 + len(k)
		off += 4 + len(v)
	}

	// p.SimpleStruct ID:8 thrift.STRUCT
	off += 3
	off += p.SimpleStruct.BLength()

	// p.MapI32I64 ID:9 thrift.MAP
	off += 3
	off += 6
	off += len(p.MapI32I64) * (4 + 8)

	// p.ListString ID:10 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.ListString {
		off += 4 + len(v)
	}

	// p.Binary ID:11 thrift.STRING
	off += 3
	off += 4 + len(p.Binary)

	// p.MapI64String ID:12 thrift.MAP
	off += 3
	off += 6
	off += len(p.MapI64String) * 8
	for _, v := range p.MapI64String {
		off += 4 + len(v)
	}

	// p.ListI64 ID:13 thrift.LIST
	off += 3
	off += 5
	off += len(p.ListI64) * 8

	// p.Byte ID:14 thrift.I08
	off += 3
	off += 1

	// p.MapStringSimple ID:15 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapStringSimple {
		off += 4 + len(k)
		off += v.BLength()
	}
	return off + 1
}

func (p *Nesting) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Nesting) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.String_ ID:1 thrift.STRING
	b[off] = 11
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	off += thrift.Binary.WriteStringNocopy(b[off:], w, p.String_)

	// p.ListSimple ID:2 thrift.LIST
	b[off] = 15
	binary.BigEndian.PutUint16(b[off+1:], 2)
	off += 3
	b[off] = 12
	binary.BigEndian.PutUint32(b[off+1:], uint32(len(p.ListSimple)))
	off += 5
	for _, v := range p.ListSimple {
		off += v.FastWriteNocopy(b[off:], w)
	}

	// p.Double ID:3 thrift.DOUBLE
	b[off] = 4
	binary.BigEndian.PutUint16(b[off+1:], 3)
	off += 3
	binary.BigEndian.PutUint64(b[off:], *(*uint64)(unsafe.Pointer(&p.Double)))
	off += 8

	// p.I32 ID:4 thrift.I32
	b[off] = 8
	binary.BigEndian.PutUint16(b[off+1:], 4)
	off += 3
	binary.BigEndian.PutUint32(b[off:], uint32(p.I32))
	off += 4

	// p.ListI32 ID:5 thrift.LIST
	b[off] = 15
	binary.BigEndian.PutUint16(b[off+1:], 5)
	off += 3
	b[off] = 8
	binary.BigEndian.PutUint32(b[off+1:], uint32(len(p.ListI32)))
	off += 5
	for _, v := range p.ListI32 {
		binary.BigEndian.PutUint32(b[off:], uint32(v))
		off += 4
	}

	// p.I64 ID:6 thrift.I64
	b[off] = 10
	binary.BigEndian.PutUint16(b[off+1:], 6)
	off += 3
	binary.BigEndian.PutUint64(b[off:], uint64(p.I64))
	off += 8

	// p.MapStringString ID:7 thrift.MAP
	b[off] = 13
	binary.BigEndian.PutUint16(b[off+1:], 7)
	off += 3
	b[off] = 11
	b[off+1] = 11
	binary.BigEndian.PutUint32(b[off+2:], uint32(len(p.MapStringString)))
	off += 6
	for k, v := range p.MapStringString {
		off += thrift.Binary.WriteStringNocopy(b[off:], w, k)
		off += thrift.Binary.WriteStringNocopy(b[off:], w, v)
	}

	// p.SimpleStruct ID:8 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 8)
	off += 3
	off += p.SimpleStruct.FastWriteNocopy(b[off:], w)

	// p.MapI32I64 ID:9 thrift.MAP
	b[off] = 13
	binary.BigEndian.PutUint16(b[off+1:], 9)
	off += 3
	b[off] = 8
	b[off+1] = 10
	binary.BigEndian.PutUint32(b[off+2:], uint32(len(p.MapI32I64)))
	off += 6
	for k, v := range p.MapI32I64 {
		binary.BigEndian.PutUint32(b[off:], uint32(k))
		off += 4
		binary.BigEndian.PutUint64(b[off:], uint64(v))
		off += 8
	}

	// p.ListString ID:10 thrift.LIST
	b[off] = 15
	binary.BigEndian.PutUint16(b[off+1:], 10)
	off += 3
	b[off] = 11
	binary.BigEndian.PutUint32(b[off+1:], uint32(len(p.ListString)))
	off += 5
	for _, v := range p.ListString {
		off += thrift.Binary.WriteStringNocopy(b[off:], w, v)
	}

	// p.Binary ID:11 thrift.STRING
	b[off] = 11
	binary.BigEndian.PutUint16(b[off+1:], 11)
	off += 3
	off += thrift.Binary.WriteBinaryNocopy(b[off:], w, p.Binary)

	// p.MapI64String ID:12 thrift.MAP
	b[off] = 13
	binary.BigEndian.PutUint16(b[off+1:], 12)
	off += 3
	b[off] = 10
	b[off+1] = 11
	binary.BigEndian.PutUint32(b[off+2:], uint32(len(p.MapI64String)))
	off += 6
	for k, v := range p.MapI64String {
		binary.BigEndian.PutUint64(b[off:], uint64(k))
		off += 8
		off += thrift.Binary.WriteStringNocopy(b[off:], w, v)
	}

	// p.ListI64 ID:13 thrift.LIST
	b[off] = 15
	binary.BigEndian.PutUint16(b[off+1:], 13)
	off += 3
	b[off] = 10
	binary.BigEndian.PutUint32(b[off+1:], uint32(len(p.ListI64)))
	off += 5
	for _, v := range p.ListI64 {
		binary.BigEndian.PutUint64(b[off:], uint64(v))
		off += 8
	}

	// p.Byte ID:14 thrift.I08
	b[off] = 3
	binary.BigEndian.PutUint16(b[off+1:], 14)
	off += 3
	b[off] = byte(p.Byte)
	off++

	// p.MapStringSimple ID:15 thrift.MAP
	b[off] = 13
	binary.BigEndian.PutUint16(b[off+1:], 15)
	off += 3
	b[off] = 11
	b[off+1] = 12
	binary.BigEndian.PutUint32(b[off+2:], uint32(len(p.MapStringSimple)))
	off += 6
	for k, v := range p.MapStringSimple {
		off += thrift.Binary.WriteStringNocopy(b[off:], w, k)
		off += v.FastWriteNocopy(b[off:], w)
	}

	b[off] = 0
	return off + 1
}

func (p *Nesting) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.String_ ID:1 thrift.STRING
			p.String_, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20f: // p.ListSimple ID:2 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListSimple = make([]*Simple, sz)
			for i := 0; i < sz; i++ {
				p.ListSimple[i] = NewSimple()
				l, err = p.ListSimple[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x304: // p.Double ID:3 thrift.DOUBLE
			p.Double, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x408: // p.I32 ID:4 thrift.I32
			p.I32, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50f: // p.ListI32 ID:5 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListI32 = make([]int32, sz)
			for i := 0; i < sz; i++ {
				p.ListI32[i], l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x60a: // p.I64 ID:6 thrift.I64
			p.I64, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x70d: // p.MapStringString ID:7 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringString = make(map[string]string, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v string
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringString[k] = v
			}
		case 0x80c: // p.SimpleStruct ID:8 thrift.STRUCT
			p.SimpleStruct = NewSimple()
			l, err = p.SimpleStruct.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x90d: // p.MapI32I64 ID:9 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapI32I64 = make(map[int32]int64, sz)
			for i := 0; i < sz; i++ {
				var k int32
				var v int64
				k, l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapI32I64[k] = v
			}
		case 0xa0f: // p.ListString ID:10 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListString = make([]string, sz)
			for i := 0; i < sz; i++ {
				p.ListString[i], l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xb0b: // p.Binary ID:11 thrift.STRING
			p.Binary, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0xc0d: // p.MapI64String ID:12 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapI64String = make(map[int64]string, sz)
			for i := 0; i < sz; i++ {
				var k int64
				var v string
				k, l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapI64String[k] = v
			}
		case 0xd0f: // p.ListI64 ID:13 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListI64 = make([]int64, sz)
			for i := 0; i < sz; i++ {
				p.ListI64[i], l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xe03: // p.Byte ID:14 thrift.I08
			p.Byte, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0xf0d: // p.MapStringSimple ID:15 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringSimple = make(map[string]*Simple, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v *Simple
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v = NewSimple()
				l, err = v.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringSimple[k] = v
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Nesting[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *PartialNesting) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.ListSimple ID:2 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.ListSimple {
		off += v.BLength()
	}

	// p.SimpleStruct ID:8 thrift.STRUCT
	off += 3
	off += p.SimpleStruct.BLength()

	// p.MapStringSimple ID:15 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapStringSimple {
		off += 4 + len(k)
		off += v.BLength()
	}
	return off + 1
}

func (p *PartialNesting) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *PartialNesting) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.ListSimple ID:2 thrift.LIST
	b[off] = 15
	binary.BigEndian.PutUint16(b[off+1:], 2)
	off += 3
	b[off] = 12
	binary.BigEndian.PutUint32(b[off+1:], uint32(len(p.ListSimple)))
	off += 5
	for _, v := range p.ListSimple {
		off += v.FastWriteNocopy(b[off:], w)
	}

	// p.SimpleStruct ID:8 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 8)
	off += 3
	off += p.SimpleStruct.FastWriteNocopy(b[off:], w)

	// p.MapStringSimple ID:15 thrift.MAP
	b[off] = 13
	binary.BigEndian.PutUint16(b[off+1:], 15)
	off += 3
	b[off] = 11
	b[off+1] = 12
	binary.BigEndian.PutUint32(b[off+2:], uint32(len(p.MapStringSimple)))
	off += 6
	for k, v := range p.MapStringSimple {
		off += thrift.Binary.WriteStringNocopy(b[off:], w, k)
		off += v.FastWriteNocopy(b[off:], w)
	}

	b[off] = 0
	return off + 1
}

func (p *PartialNesting) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x20f: // p.ListSimple ID:2 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListSimple = make([]*PartialSimple, sz)
			for i := 0; i < sz; i++ {
				p.ListSimple[i] = NewPartialSimple()
				l, err = p.ListSimple[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x80c: // p.SimpleStruct ID:8 thrift.STRUCT
			p.SimpleStruct = NewPartialSimple()
			l, err = p.SimpleStruct.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0xf0d: // p.MapStringSimple ID:15 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringSimple = make(map[string]*PartialSimple, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v *PartialSimple
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v = NewPartialSimple()
				l, err = v.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringSimple[k] = v
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_PartialNesting[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Nesting2) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.MapSimpleNesting ID:1 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapSimpleNesting {
		off += k.BLength()
		off += v.BLength()
	}

	// p.SimpleStruct ID:2 thrift.STRUCT
	off += 3
	off += p.SimpleStruct.BLength()

	// p.Byte ID:3 thrift.I08
	off += 3
	off += 1

	// p.Double ID:4 thrift.DOUBLE
	off += 3
	off += 8

	// p.ListNesting ID:5 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.ListNesting {
		off += v.BLength()
	}

	// p.I64 ID:6 thrift.I64
	off += 3
	off += 8

	// p.NestingStruct ID:7 thrift.STRUCT
	off += 3
	off += p.NestingStruct.BLength()

	// p.Binary ID:8 thrift.STRING
	off += 3
	off += 4 + len(p.Binary)

	// p.String_ ID:9 thrift.STRING
	off += 3
	off += 4 + len(p.String_)

	// p.SetNesting ID:10 thrift.SET
	off += 3
	off += 5
	for _, v := range p.SetNesting {
		off += v.BLength()
	}

	// p.I32 ID:11 thrift.I32
	off += 3
	off += 4
	return off + 1
}

func (p *Nesting2) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Nesting2) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.MapSimpleNesting ID:1 thrift.MAP
	b[off] = 13
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	b[off] = 12
	b[off+1] = 12
	binary.BigEndian.PutUint32(b[off+2:], uint32(len(p.MapSimpleNesting)))
	off += 6
	for k, v := range p.MapSimpleNesting {
		off += k.FastWriteNocopy(b[off:], w)
		off += v.FastWriteNocopy(b[off:], w)
	}

	// p.SimpleStruct ID:2 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 2)
	off += 3
	off += p.SimpleStruct.FastWriteNocopy(b[off:], w)

	// p.Byte ID:3 thrift.I08
	b[off] = 3
	binary.BigEndian.PutUint16(b[off+1:], 3)
	off += 3
	b[off] = byte(p.Byte)
	off++

	// p.Double ID:4 thrift.DOUBLE
	b[off] = 4
	binary.BigEndian.PutUint16(b[off+1:], 4)
	off += 3
	binary.BigEndian.PutUint64(b[off:], *(*uint64)(unsafe.Pointer(&p.Double)))
	off += 8

	// p.ListNesting ID:5 thrift.LIST
	b[off] = 15
	binary.BigEndian.PutUint16(b[off+1:], 5)
	off += 3
	b[off] = 12
	binary.BigEndian.PutUint32(b[off+1:], uint32(len(p.ListNesting)))
	off += 5
	for _, v := range p.ListNesting {
		off += v.FastWriteNocopy(b[off:], w)
	}

	// p.I64 ID:6 thrift.I64
	b[off] = 10
	binary.BigEndian.PutUint16(b[off+1:], 6)
	off += 3
	binary.BigEndian.PutUint64(b[off:], uint64(p.I64))
	off += 8

	// p.NestingStruct ID:7 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 7)
	off += 3
	off += p.NestingStruct.FastWriteNocopy(b[off:], w)

	// p.Binary ID:8 thrift.STRING
	b[off] = 11
	binary.BigEndian.PutUint16(b[off+1:], 8)
	off += 3
	off += thrift.Binary.WriteBinaryNocopy(b[off:], w, p.Binary)

	// p.String_ ID:9 thrift.STRING
	b[off] = 11
	binary.BigEndian.PutUint16(b[off+1:], 9)
	off += 3
	off += thrift.Binary.WriteStringNocopy(b[off:], w, p.String_)

	// p.SetNesting ID:10 thrift.SET
	b[off] = 14
	binary.BigEndian.PutUint16(b[off+1:], 10)
	off += 3
	b[off] = 12
	binary.BigEndian.PutUint32(b[off+1:], uint32(len(p.SetNesting)))
	off += 5
	for _, v := range p.SetNesting {
		off += v.FastWriteNocopy(b[off:], w)
	}

	// p.I32 ID:11 thrift.I32
	b[off] = 8
	binary.BigEndian.PutUint16(b[off+1:], 11)
	off += 3
	binary.BigEndian.PutUint32(b[off:], uint32(p.I32))
	off += 4

	b[off] = 0
	return off + 1
}

func (p *Nesting2) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10d: // p.MapSimpleNesting ID:1 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapSimpleNesting = make(map[*Simple]*Nesting, sz)
			for i := 0; i < sz; i++ {
				var k *Simple
				var v *Nesting
				k = NewSimple()
				l, err = k.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v = NewNesting()
				l, err = v.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapSimpleNesting[k] = v
			}
		case 0x20c: // p.SimpleStruct ID:2 thrift.STRUCT
			p.SimpleStruct = NewSimple()
			l, err = p.SimpleStruct.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x303: // p.Byte ID:3 thrift.I08
			p.Byte, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x404: // p.Double ID:4 thrift.DOUBLE
			p.Double, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50f: // p.ListNesting ID:5 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListNesting = make([]*Nesting, sz)
			for i := 0; i < sz; i++ {
				p.ListNesting[i] = NewNesting()
				l, err = p.ListNesting[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x60a: // p.I64 ID:6 thrift.I64
			p.I64, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x70c: // p.NestingStruct ID:7 thrift.STRUCT
			p.NestingStruct = NewNesting()
			l, err = p.NestingStruct.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x80b: // p.Binary ID:8 thrift.STRING
			p.Binary, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x90b: // p.String_ ID:9 thrift.STRING
			p.String_, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0xa0e: // p.SetNesting ID:10 thrift.SET
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.SetNesting = make([]*Nesting, sz)
			for i := 0; i < sz; i++ {
				p.SetNesting[i] = NewNesting()
				l, err = p.SetNesting[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xb08: // p.I32 ID:11 thrift.I32
			p.I32, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Nesting2[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServiceSimpleMethodArgs) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	off += 3
	off += p.Req.BLength()
	return off + 1
}

func (p *BaselineServiceSimpleMethodArgs) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *BaselineServiceSimpleMethodArgs) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	off += p.Req.FastWriteNocopy(b[off:], w)

	b[off] = 0
	return off + 1
}

func (p *BaselineServiceSimpleMethodArgs) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10c: // p.Req ID:1 thrift.STRUCT
			p.Req = NewSimple()
			l, err = p.Req.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServiceSimpleMethodArgs[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServiceSimpleMethodResult) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		off += 3
		off += p.Success.BLength()
	}
	return off + 1
}

func (p *BaselineServiceSimpleMethodResult) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *BaselineServiceSimpleMethodResult) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		b[off] = 12
		binary.BigEndian.PutUint16(b[off+1:], 0)
		off += 3
		off += p.Success.FastWriteNocopy(b[off:], w)
	}

	b[off] = 0
	return off + 1
}

func (p *BaselineServiceSimpleMethodResult) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0xc: // p.Success ID:0 thrift.STRUCT
			p.Success = NewSimple()
			l, err = p.Success.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServiceSimpleMethodResult[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServicePartialSimpleMethodArgs) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	off += 3
	off += p.Req.BLength()
	return off + 1
}

func (p *BaselineServicePartialSimpleMethodArgs) FastWrite(b []byte) int {
	return p.FastWriteNocopy(b, nil)
}

func (p *BaselineServicePartialSimpleMethodArgs) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	off += p.Req.FastWriteNocopy(b[off:], w)

	b[off] = 0
	return off + 1
}

func (p *BaselineServicePartialSimpleMethodArgs) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10c: // p.Req ID:1 thrift.STRUCT
			p.Req = NewPartialSimple()
			l, err = p.Req.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServicePartialSimpleMethodArgs[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServicePartialSimpleMethodResult) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		off += 3
		off += p.Success.BLength()
	}
	return off + 1
}

func (p *BaselineServicePartialSimpleMethodResult) FastWrite(b []byte) int {
	return p.FastWriteNocopy(b, nil)
}

func (p *BaselineServicePartialSimpleMethodResult) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		b[off] = 12
		binary.BigEndian.PutUint16(b[off+1:], 0)
		off += 3
		off += p.Success.FastWriteNocopy(b[off:], w)
	}

	b[off] = 0
	return off + 1
}

func (p *BaselineServicePartialSimpleMethodResult) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0xc: // p.Success ID:0 thrift.STRUCT
			p.Success = NewPartialSimple()
			l, err = p.Success.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServicePartialSimpleMethodResult[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServiceNestingMethodArgs) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	off += 3
	off += p.Req.BLength()
	return off + 1
}

func (p *BaselineServiceNestingMethodArgs) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *BaselineServiceNestingMethodArgs) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	off += p.Req.FastWriteNocopy(b[off:], w)

	b[off] = 0
	return off + 1
}

func (p *BaselineServiceNestingMethodArgs) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10c: // p.Req ID:1 thrift.STRUCT
			p.Req = NewNesting()
			l, err = p.Req.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServiceNestingMethodArgs[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServiceNestingMethodResult) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		off += 3
		off += p.Success.BLength()
	}
	return off + 1
}

func (p *BaselineServiceNestingMethodResult) FastWrite(b []byte) int {
	return p.FastWriteNocopy(b, nil)
}

func (p *BaselineServiceNestingMethodResult) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		b[off] = 12
		binary.BigEndian.PutUint16(b[off+1:], 0)
		off += 3
		off += p.Success.FastWriteNocopy(b[off:], w)
	}

	b[off] = 0
	return off + 1
}

func (p *BaselineServiceNestingMethodResult) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0xc: // p.Success ID:0 thrift.STRUCT
			p.Success = NewNesting()
			l, err = p.Success.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServiceNestingMethodResult[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServicePartialNestingMethodArgs) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	off += 3
	off += p.Req.BLength()
	return off + 1
}

func (p *BaselineServicePartialNestingMethodArgs) FastWrite(b []byte) int {
	return p.FastWriteNocopy(b, nil)
}

func (p *BaselineServicePartialNestingMethodArgs) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	off += p.Req.FastWriteNocopy(b[off:], w)

	b[off] = 0
	return off + 1
}

func (p *BaselineServicePartialNestingMethodArgs) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10c: // p.Req ID:1 thrift.STRUCT
			p.Req = NewPartialNesting()
			l, err = p.Req.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServicePartialNestingMethodArgs[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServicePartialNestingMethodResult) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		off += 3
		off += p.Success.BLength()
	}
	return off + 1
}

func (p *BaselineServicePartialNestingMethodResult) FastWrite(b []byte) int {
	return p.FastWriteNocopy(b, nil)
}

func (p *BaselineServicePartialNestingMethodResult) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		b[off] = 12
		binary.BigEndian.PutUint16(b[off+1:], 0)
		off += 3
		off += p.Success.FastWriteNocopy(b[off:], w)
	}

	b[off] = 0
	return off + 1
}

func (p *BaselineServicePartialNestingMethodResult) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0xc: // p.Success ID:0 thrift.STRUCT
			p.Success = NewPartialNesting()
			l, err = p.Success.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServicePartialNestingMethodResult[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServiceNesting2MethodArgs) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	off += 3
	off += p.Req.BLength()
	return off + 1
}

func (p *BaselineServiceNesting2MethodArgs) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *BaselineServiceNesting2MethodArgs) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Req ID:1 thrift.STRUCT
	b[off] = 12
	binary.BigEndian.PutUint16(b[off+1:], 1)
	off += 3
	off += p.Req.FastWriteNocopy(b[off:], w)

	b[off] = 0
	return off + 1
}

func (p *BaselineServiceNesting2MethodArgs) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10c: // p.Req ID:1 thrift.STRUCT
			p.Req = NewNesting2()
			l, err = p.Req.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServiceNesting2MethodArgs[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *BaselineServiceNesting2MethodResult) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		off += 3
		off += p.Success.BLength()
	}
	return off + 1
}

func (p *BaselineServiceNesting2MethodResult) FastWrite(b []byte) int {
	return p.FastWriteNocopy(b, nil)
}

func (p *BaselineServiceNesting2MethodResult) FastWriteNocopy(b []byte, w thrift.NocopyWriter) int {
	if p == nil {
		b[0] = 0
		return 1
	}
	off := 0

	// p.Success ID:0 thrift.STRUCT
	if p.Success != nil {
		b[off] = 12
		binary.BigEndian.PutUint16(b[off+1:], 0)
		off += 3
		off += p.Success.FastWriteNocopy(b[off:], w)
	}

	b[off] = 0
	return off + 1
}

func (p *BaselineServiceNesting2MethodResult) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0xc: // p.Success ID:0 thrift.STRUCT
			p.Success = NewNesting2()
			l, err = p.Success.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_BaselineServiceNesting2MethodResult[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}
